package gomakemkv

import (
	"strconv"

	"github.com/DrWalrus1/gomakemkv/events"
	"github.com/DrWalrus1/gomakemkv/events/codes"
)

// A data structure to store the metadata generated by makemkv when reading disc info
type MkvDiscInfo struct {
	Name     string        `json:"name"`
	Language string        `json:"language"`
	Type     string        `json:"type"`
	Titles   map[int]Title `json:"titles"`
}

func NewDisc() MkvDiscInfo {
	return MkvDiscInfo{
		Titles: make(map[int]Title),
	}
}

// Function updates or insert disc information by matching the id
// to the field.
func (di *MkvDiscInfo) updateDiscInfo(info events.DiscInformation) {
	switch info.ID {
	case codes.Name:
		di.Name = info.Value
	case codes.MetadataLanguageName:
		di.Language = info.Value
	case codes.Type:
		di.Type = info.Value
	}
}

func (di *MkvDiscInfo) upsertDiscTitleMetadata(info events.TitleInformation) {
	title, exists := di.Titles[info.TitleIndex]
	if !exists {
		title = NewTitle(strconv.Itoa(info.TitleIndex))
	}
	title.updateTitle(info)
	di.Titles[info.TitleIndex] = title
}

func (di *MkvDiscInfo) upsertTitleStreamMetadata(info events.StreamInformation) {
	title, exists := di.Titles[info.TitleIndex]
	if !exists {
		title = NewTitle(strconv.Itoa(info.TitleIndex))
	}
	title.upsertStreamData(info)
	di.Titles[info.TitleIndex] = title
}

// Struct for store title metadata
type Title struct {
	Id             string                `json:"id"`
	Name           string                `json:"name"`
	Size           string                `json:"size"`
	SizeInBytes    string                `json:"sizeInBytes"`
	Duration       string                `json:"duration"`
	Language       string                `json:"language"`
	Chapters       string                `json:"chapters"`
	OutputFileName string                `json:"outputFileName"`
	VideoTracks    map[int]VideoTrack    `json:"video"`
	AudioTracks    map[int]AudioTrack    `json:"audio"`
	SubtitleTracks map[int]SubtitleTrack `json:"subtitles"`
}

func NewTitle(id string) Title {
	return Title{
		Id:             id,
		VideoTracks:    make(map[int]VideoTrack),
		AudioTracks:    make(map[int]AudioTrack),
		SubtitleTracks: make(map[int]SubtitleTrack),
	}
}

func (t *Title) updateTitle(info events.TitleInformation) {
	switch info.AttributeId {
	case codes.Name:
		t.Name = info.Value
	case codes.DiskSize:
		t.Size = info.Value
	case codes.DiskSizeBytes:
		t.SizeInBytes = info.Value
	case codes.Duration:
		t.Duration = info.Value
	case codes.MetadataLanguageName:
		t.Language = info.Value
	case codes.ChapterCount:
		t.Chapters = info.Value
	case codes.OutputFileName:
		t.OutputFileName = info.Value
	}
}

func (t *Title) upsertStreamData(info events.StreamInformation) {
	// Create new stream if the type is detected
	if info.AttributeId == codes.Type {
		switch info.Value {
		case "Video":
			t.VideoTracks[info.StreamIndex] = VideoTrack{
				Type: info.Value,
			}
		case "Audio":
			t.AudioTracks[info.StreamIndex] = AudioTrack{
				Type: info.Value,
			}
		default:
			t.SubtitleTracks[info.StreamIndex] = SubtitleTrack{
				Type: info.Value,
			}
		}
	}
	videoTrack, ok := t.VideoTracks[info.StreamIndex]
	if ok {
		videoTrack.updateVideoTrack(info)
		t.VideoTracks[info.StreamIndex] = videoTrack
		return
	}
	audioTrack, ok := t.AudioTracks[info.StreamIndex]
	if ok {
		audioTrack.updateAudioTrack(info)
		t.AudioTracks[info.StreamIndex] = audioTrack
		return
	}

	subtitleTrack, ok := t.SubtitleTracks[info.StreamIndex]
	if ok {
		subtitleTrack.updateSubtitleTrack(info)
		t.SubtitleTracks[info.StreamIndex] = subtitleTrack
		return
	}
	panic("Attempted to parse out of order stream information")
	// TODO: CONSIDER making the array a queue. if we don't find the type first skip for now and re-enqueue

}

// Struct for storing video specific metadata for a particular [Title]
type VideoTrack struct {
	Type           string `json:"type"`
	Framerate      string `json:"framerate"`
	VideoSize      string `json:"videoSize"`
	Codec          string `json:"codec"`
	Language       string `json:"language"`
	ConversionType string `json:"conversionType"`
}

func (vt *VideoTrack) updateVideoTrack(info events.StreamInformation) {
	switch info.AttributeId {
	case codes.VideoFrameRate:
		vt.Framerate = info.Value
	case codes.VideoSize:
		vt.VideoSize = info.Value
	case codes.CodecShort:
		vt.Codec = info.Value
	case codes.MetadataLanguageName:
		vt.Language = info.Value
	case codes.OutputConversionType:
		vt.ConversionType = info.Value
	}
}

// Struct for storing audio specific metadata for a particular [Title]
type AudioTrack struct {
	Type           string `json:"type"`
	Name           string `json:"name"`
	Language       string `json:"language"`
	Bitrate        string `json:"bitrate"`
	SampleRate     string `json:"sampleRate"`
	SampleSize     string `json:"sampleSize"`
	ChannelNumbers string `json:"channelNumbers"`
	ConversionType string `json:"conversionType"`
}

func (vt *AudioTrack) updateAudioTrack(info events.StreamInformation) {
	switch info.AttributeId {
	case codes.Name:
		vt.Name = info.Value
	case codes.MetadataLanguageName:
		vt.Language = info.Value
	case codes.Bitrate:
		vt.Bitrate = info.Value
	case codes.AudioSampleRate:
		vt.SampleRate = info.Value
	case codes.AudioSampleSize:
		vt.SampleSize = info.Value
	case codes.AudioChannelsCount:
		vt.ChannelNumbers = info.Value
	case codes.OutputConversionType:
		vt.ConversionType = info.Value
	}
}

// Struct for storing subtitle specific metadata for a particular [Title]
type SubtitleTrack struct {
	Type           string `json:"type"`
	Language       string `json:"language"`
	Codec          string `json:"codec"`
	ConversionType string `json:"conversionType"`
}

func (vt *SubtitleTrack) updateSubtitleTrack(info events.StreamInformation) {
	switch info.AttributeId {
	case codes.MetadataLanguageName:
		vt.Language = info.Value
	case codes.CodecShort:
		vt.Codec = info.Value
	case codes.OutputConversionType:
		vt.ConversionType = info.Value
	}

}

// Function for converting a collection of [events.MakeMkvOutput] into a complete MkvDiscInfo structure
func MakeMkvEventsIntoMakeMkvDiscInfo(makemkvevents []events.MakeMkvOutput) MkvDiscInfo {
	mkvDiscInfo := NewDisc()
	for _, x := range makemkvevents {
		if i, ok := x.(*events.DiscInformation); ok {
			mkvDiscInfo.updateDiscInfo(*i)
		} else if i, ok := x.(*events.TitleInformation); ok {
			mkvDiscInfo.upsertDiscTitleMetadata(*i)
		} else if i, ok := x.(*events.StreamInformation); ok {
			mkvDiscInfo.upsertTitleStreamMetadata(*i)
		}
	}
	return mkvDiscInfo
}
